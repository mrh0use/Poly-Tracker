Fix volatility alerts that are mixing different market outcomes and alerting on both Yes and No:
Problem

Prices from different market outcomes (e.g., different spread lines) are being mixed together because we're using conditionId which can be shared across related markets
We're alerting on both Yes AND No price changes, which is redundant since they're inverses

Changes to bot.py:
1. In handle_websocket_trade, fix how we identify markets for volatility tracking
Find the volatility tracking section (around line 1995-2001) that looks like:
python    # VOLATILITY TRACKING: Record price for ALL trades (before any filtering)
    price = float(trade.get('price', 0) or 0)
    condition_id = trade.get('conditionId') or trade.get('condition_id') or trade.get('asset_id', '')
    if condition_id and price > 0:
        market_title = trade.get('title', '') or polymarket_client.get_market_title(trade)
        slug = trade.get('slug', '') or polymarket_client.get_market_slug(trade)
        volatility_manager.record_price(condition_id, price, market_title, slug)
Replace with:
python    # VOLATILITY TRACKING: Record price for ALL trades (before any filtering)
    # Use asset (token ID) not conditionId to avoid mixing different outcomes
    # Only track "Yes" outcomes to avoid redundant Yes/No alerts (they're inverses)
    price = float(trade.get('price', 0) or 0)
    asset_id = trade.get('asset', '')
    outcome = trade.get('outcome', 'Yes')
    outcome_index = trade.get('outcomeIndex', 0)
    
    # Only track Yes outcomes (outcomeIndex 0) to avoid duplicate alerts
    # No price is just (1 - Yes price), so tracking both is redundant
    if asset_id and price > 0 and (outcome == 'Yes' or outcome_index == 0):
        market_title = trade.get('title', '') or polymarket_client.get_market_title(trade)
        slug = trade.get('slug', '') or polymarket_client.get_market_slug(trade)
        volatility_manager.record_price(asset_id, price, market_title, slug)
        
        # Check for volatility alerts
        if bot.is_ready():
            all_configs = get_cached_server_configs()
            volatility_configs = [c for c in all_configs if not c.is_paused and c.volatility_channel_id]
            
            for config in volatility_configs:
                threshold = config.volatility_threshold or 5.0
                
                # Category filter if configured
                category_filter = getattr(config, 'volatility_category', 'all') or 'all'
                if category_filter != 'all':
                    market_category = polymarket_client.detect_market_category(trade)
                    if market_category != category_filter:
                        continue
                
                alert = volatility_manager.check_volatility(asset_id, config.guild_id, threshold)
                
                if alert:
                    try:
                        vol_session = get_session()
                        cooldown_time = datetime.utcnow() - timedelta(minutes=15)
                        recent_db_alert = vol_session.query(VolatilityAlert).filter(
                            VolatilityAlert.condition_id == asset_id,
                            VolatilityAlert.alerted_at >= cooldown_time
                        ).first()
                        
                        if not recent_db_alert:
                            print(f"[VOLATILITY] ðŸš¨ {alert['time_window_minutes']}min alert: {alert['title'][:40]}... {alert['price_change_pct']:+.1f} pts ({alert['old_price']*100:.0f}%â†’{alert['new_price']*100:.0f}%)", flush=True)
                            channel = await get_or_fetch_channel(config.volatility_channel_id)
                            if channel:
                                embed, vol_market_url = create_volatility_alert_embed(
                                    market_title=alert['title'],
                                    slug=alert['slug'],
                                    old_price=alert['old_price'],
                                    new_price=alert['new_price'],
                                    price_change=alert['price_change_pct'],
                                    time_window_minutes=alert['time_window_minutes']
                                )
                                vol_event_slug = polymarket_client.get_event_slug_by_condition(asset_id, alert['slug'])
                                button_view = create_trade_button_view(vol_event_slug, vol_market_url)
                                
                                try:
                                    message = await channel.send(embed=embed, view=button_view)
                                    vol_session.add(VolatilityAlert(condition_id=asset_id, price_change=alert['price_change_pct']))
                                    vol_session.commit()
                                    _ws_stats['alerts_sent'] += 1
                                    print(f"[VOLATILITY] âœ“ ALERT SENT to channel {config.volatility_channel_id}", flush=True)
                                except Exception as e:
                                    print(f"[VOLATILITY] âœ— ERROR: {e}", flush=True)
                        vol_session.close()
                    except Exception as e:
                        print(f"[VOLATILITY] DB error: {e}", flush=True)
2. Also fix the SELL tracking section
Find the SELL handling (around line 1991-1993) and update it to also use asset and filter to Yes only:
python    # Record price for SELLs (they move markets too!) but don't process further
    if side == 'SELL':
        price = float(trade.get('price', 0) or 0)
        asset_id = trade.get('asset', '')
        outcome = trade.get('outcome', 'Yes')
        outcome_index = trade.get('outcomeIndex', 0)
        # Only track Yes outcomes
        if asset_id and price > 0 and (outcome == 'Yes' or outcome_index == 0):
            market_title = trade.get('title', '') or polymarket_client.get_market_title(trade)
            slug = trade.get('slug', '') or polymarket_client.get_market_slug(trade)
            volatility_manager.record_price(asset_id, price, market_title, slug)
        return

Summary of fixes:
ProblemFixDifferent spread lines mixed togetherUse asset (token ID) instead of conditionIdYes and No both alertingOnly track outcome == 'Yes' or outcomeIndex == 047%â†’53% false alertEach token now tracked separately, no cross-contamination