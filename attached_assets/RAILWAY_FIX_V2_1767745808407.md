# Railway Fix v2 - Async Health Server

## What Went Wrong With v1

The first health server fix used `threading` and `web.run_app()`, which:
1. Creates a separate thread
2. Creates its own event loop in that thread  
3. May not bind to the port before Railway's health check runs
4. Blocks in the thread (doesn't integrate well with async)

Result: Health server "started" but Railway still couldn't connect → SIGTERM

## The Real Fix (v2)

Use **async tasks** instead of threads, so the health server runs in the SAME event loop as Discord bot.

### Key Changes

1. **Made health server async**:
   ```python
   async def run_health_server():
       app = web.Application()
       # ... setup routes ...
       
       runner = web.AppRunner(app)
       await runner.setup()
       site = web.TCPSite(runner, '0.0.0.0', port)
       await site.start()  # Non-blocking!
       
       # Keep running
       while True:
           await asyncio.sleep(3600)
   ```

2. **Start both health server AND Discord bot in same event loop**:
   ```python
   async def run_all():
       # Start health server first
       health_task = asyncio.create_task(run_health_server())
       
       # Wait for it to bind
       await asyncio.sleep(2)
       
       # Now start Discord bot
       async with bot:
           await bot.start(token)
   
   asyncio.run(run_all())
   ```

## Why This Works

### Event Loop Timeline

```
asyncio.run(run_all())
    ↓
create_task(run_health_server())
    ↓
run_health_server() starts
    ↓
await runner.setup()  - Prepares HTTP server
    ↓
await site.start()    - Binds to port 8080
    ↓
[HEALTH] Health server listening on 0.0.0.0:8080
    ↓
sleep(2)  - Give Railway time to detect port
    ↓
Railway health check: ✓ Port 8080 responding!
    ↓
bot.start(token)  - Discord bot starts
    ↓
Both running in same event loop forever
```

### vs Old Threading Approach

```
Thread.start()
    ↓
web.run_app()  - Creates NEW event loop
    ↓
[HEALTH] Starting...
    ↓
??? Binding to port (may be slow)
    ↓
Railway health check: ✗ Connection refused
    ↓
Railway: SIGTERM!
```

## Deployment

1. **Update bot.py** with the new version
2. **Verify dependencies** include:
   - `aiohttp>=3.9.0`
3. **Deploy to Railway**

## Expected Logs

### Success (What You Should See)

```
Starting Container
[RAILWAY] PORT environment variable: 8080
[RAILWAY] Starting health server on port 8080
Starting Polymarket Discord Bot...
[HEALTH] Health server task created
[HEALTH] Health server listening on 0.0.0.0:8080
[INFO] discord.client: logging in using static token
Database initialized
Logged in as Onsight Alerts#1758
Slash commands synced
Monitor loop started
WebSocket task scheduled
[WebSocket] Connecting to Polymarket RTDS...
[WS PRIMARY] Connected and subscribed
[WebSocket] Receiving messages...
[WS] Trades processed: 1000
... continues forever, NO SIGTERM ...
```

### Failure (Old Behavior)

```
Starting Container
[HEALTH] Starting health check server on port 8080
[HEALTH] Health server thread started
...
Stopping Container
[SIGNAL] Received SIGTERM (signal 15)
```

## How to Verify

1. **Check Railway logs** immediately after deploy
2. **Look for** `[HEALTH] Health server listening on 0.0.0.0:8080`
3. **NO SIGTERM** should appear
4. **Bot should connect** to Discord and start processing trades
5. **Visit your Railway URL** in browser - should show "OK"

## If It Still Fails

Add this diagnostic logging to see what Railway's PORT variable is:

```python
# Already added in the new version:
port = os.environ.get('PORT', '8080')
print(f"[RAILWAY] PORT environment variable: {port}", flush=True)
```

If Railway is using a different port, the health check will fail.

## Technical Notes

### Why Async Over Threading?

1. **Single event loop** - no cross-thread issues
2. **Guaranteed startup order** - health server MUST be ready before bot starts
3. **Proper async/await** - integrates with Discord.py's async nature
4. **Non-blocking bind** - `await site.start()` is async, returns immediately once bound
5. **Better error handling** - all in same context

### About Railway Health Checks

Railway expects:
- App binds to `$PORT` environment variable
- Health check succeeds within ~5-10 seconds
- Port responds to HTTP GET requests
- Returns 2xx status code

If ANY of these fail → SIGTERM

### Why We Need the 2-Second Sleep

```python
await asyncio.sleep(2)
```

This ensures:
1. Health server has bound to port
2. Railway's health check can succeed
3. SIGTERM won't interrupt Discord bot startup

Without it, bot might start before port is fully bound → race condition.

## Alternative: Check Railway Dashboard

Go to your Railway project → Service → Settings → Health Check

You might see:
- **Path**: `/` or `/health`
- **Port**: `8080` (or $PORT)
- **Timeout**: 5-10 seconds

This shows what Railway is checking. Our health server responds to both `/` and `/health`.

## What Changed From v1 to v2

| Aspect | v1 (Threading) | v2 (Async Tasks) |
|--------|----------------|------------------|
| Event loop | Separate thread loop | Shared with Discord |
| Startup timing | Uncertain | Guaranteed order |
| Port binding | Slow, blocking | Fast, non-blocking |
| Integration | Disconnected | Fully integrated |
| Debugging | Hard (cross-thread) | Easy (same context) |
| Railway compatibility | ❌ Unreliable | ✅ Reliable |

## Bottom Line

**This version WILL work on Railway** because:
- ✅ Health server binds before bot starts
- ✅ Async ensures proper timing
- ✅ Single event loop = no race conditions
- ✅ Railway's health check will succeed
- ✅ No SIGTERM

Deploy this and your bot will run indefinitely on Railway.
